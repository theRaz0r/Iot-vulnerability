# AC15_command_injection


固件版本：US_AC15V1.0BR_V15.03.05.19_multi_TD01(1).bin
复现漏洞编号：CVE-2020-10987

---


# binwalk
```
 binwalk -Me US_AC15V1.0BR_V15.03.05.19_multi_TD01\(1\).bin 
```

# 架构信息
![](vx_images/361445857167139.png)

arm-32-little

---
![](vx_images/490715287048028.png)

看不出来是用哪个起的web服务,直接qemu-user尝试一下


---

httpd服务 

```
 sudo chroot . ./qemu-arm-static ./bin/httpd
 
```


# 问题一，patch
![](vx_images/313676763127561.png)

ida中分析./bin/httpd
查找字符串 Welcome to ...

![](vx_images/56699584523811.png)
锁定为位置，动态调试。

![](vx_images/585487619543290.png)

发现程序在check-network后，走到左边了，正常逻辑应该是走右边。所以我们需要patch。


这里明显，我们让R3=1 那就可以正常执行了。


![](vx_images/38453702462606.png)

保存修改后，再调试看看。
![](vx_images/502742323761938.png)

成功向下执行了，但依然有问题。
动调看看执行流。
![](vx_images/463101833052025.png)
.text:0002E53C BNE             loc_2E558这里跳转到另一个地方了。
我们继续patch
r3和0不相等，就会正常执行，所以我们patch r3=1;
![](vx_images/94772100978838.png)


保存后执行。
![](vx_images/433404796569512.png)
成功向下执行了。

但再开启socket时候出错了。

![](vx_images/462903948152421.png)

kill了，重启程序试试。

![](vx_images/570055592533342.png)



# 问题二，网卡
这里好奇怪，为什么服务开启到255.255.255.255:80上了。

查看下ida,搜索字符串httpd listen ip

![](vx_images/78375165412651.png)

地址来源于结构体s    

```
struct sockaddr_in addr;
addr.sin_family = AF_INET;          // 地址族
addr.sin_port = htons(80);          // 端口号 (HTTP)
addr.sin_addr.s_addr = inet_addr("0.0.0.0"); // IP 地址
```


![](vx_images/507243258412171.png)

![](vx_images/149353870350370.png)

inet_addr 是一个用于将IPv4地址从点分十进制字符串转换为网络字节顺序的32位二进制数的函数。
![](vx_images/46533483541995.png)
溯源下a1

![](vx_images/257333189801673.png)

![](vx_images/421703811639836.png)

这个地址，就是存的ip。查看g_lan_ip的引用
![](vx_images/430886603726010.png)

![](vx_images/560595749973117.png)

找到对应的库./lib/libcommon.so
![](vx_images/411672838748357.png)
调用get_eth_name  且参数为0
imp_get_eth_name又是一个外部库函数 
![](vx_images/136176512359866.png)
最后发现在libChipApi.so库。

![](vx_images/566937032716717.png)

最后发现参数0，对应的网卡是br0;

---

那我们在本机上开一个br0试试。

```
 sudo tunctl -t br0
 sudo ifconfig br0 192.168.0.1/24 up
```
![](vx_images/409855804737872.png)

服务启动成功了。

![](vx_images/230985955882191.png)

---

总结一下，路由器从本地加载了一个网卡，初始化ip。

下次遇到这种我们可以直接在httpd中搜一下网卡相关的字符串 
![](vx_images/155121496706984.png)

然后直接创建网卡试试



---

# 问题三，not found 
![](vx_images/254881969259174.png)

为什么找不到页面呢？
![](vx_images/582911359946173.png)
查看下系统文件，发现web文件都在webroot_ro中。

这里服务已经起来了，但是找不到页面。
我们以前在分析启动项的时候，经常会看到有些设备，**会在初始化之后，才把htm这些文件放入web目录**。我们去看一下启动项rcS。
![](vx_images/466454192387726.png)
果然，有一个复制操作。
我们也复制一下
```
cp -rf /webroot_ro/* /webroot/
```
但是我执行这条命令有点问题，反正意思就是要把文件移动过去。你也可以直接复制一个文件夹，把名字改成webroot就行。
我用以下命令创建一个软连接，效果也是一样的。
```
sudo ln -s webroot_ro/ webroot
这条命令使用 sudo 以超级用户权限创建一个名为 webroot 的符号链接，该链接指向 webroot_ro/ 目录。这样，webroot 将成为 webroot_ro/ 的别名
```

![](vx_images/426581776802485.png)


成功模拟


---


# 漏洞分析CVE-2020-10987

![](vx_images/281103205564008.png)

CVE-2020-10987	
The goform/setUsbUnload endpoint of Tenda AC15 AC1900 version 15.03.05.19 allows remote attackers to execute arbitrary system commands via the deviceName POST parameter.


根据漏洞描述，锁定setUsbUnload中deviceName参数。

![](vx_images/415325192316321.png)

很明显，这里有个命令拼接。然后会执行。

让我们向上找调用链。

![](vx_images/169842260866928.png)
看到了很多这种格式，猜测应该是用前面的函数名，调用后面的具体函数。


我们去web文件中找一找
![](vx_images/37311930313282.png)

发现调用逻辑是从/status_usb.html调用status_usb.js，然后得到deviceName的值 


我们访问了下/status_usb.html
![](vx_images/443562748584624.png)
![](vx_images/55592849838402.png)

显示没有设备。（因为我们是模拟的，肯定这里是没有设备的）

我们直接看看status_usb.js，里面存在关键函数
![](vx_images/189154317901804.png)

只要点击了/status_usb.html中的.btn-unlink按钮，就会执行unLinkUsb函数。

```
function unLinkUsb() {
	var devName = $(this).data("target");
	$.GetSetData.setData("goform/setUsbUnload", "deviceName=" + encodeURIComponent(devName), unLinkCallback);
}
```

这里向goform/setUsbUnload 这一路径，提交了deviceName参数。

其实这里访问的时候，会一下跳过原来的界面，然后就跳到说没有设备。我们只要手速快，就能在web刷新前，点击这个按键，然后抓到包。

![](vx_images/90353312176427.png)


在本机10.254.4.19：8000上起了个http服务：

```
python -m http.server
```

![](vx_images/100902798085268.png)
发送
![](vx_images/413361534793520.png)



# 动态调试
```
sudo chroot . ./qemu-arm-static  -g 8888 ./bin/httpd
```

![](vx_images/532191213662854.png)


发送payload包
![](vx_images/91794364117675.png)


![](vx_images/353754969582745.png)

执行到sub_2BA8C函数后，查看R0指向的地址
![](vx_images/44425641927552.png)

发现里面我们的命令已经输入进来了。
![](vx_images/488554155894543.png)




接下来停在执行dosystemCmd 前，我们看下寄存器。

![](vx_images/473553637398420.png)


![](vx_images/241506027894325.png)


分别r0-3分别对应dosystemCmd的四个参数。
![](vx_images/406693966618448.png)
这里之后就lib调用库执行我们的命令了。

---
