# satc

    SaTC（Sharing More and Checking Less）是一个创新的开源工具，专为检测嵌入式系统的漏洞设计。其核心理念是利用共同的输入关键词，以更高效的方式识别潜在的漏洞，如命令注入和缓冲区溢出问题。SaTC提供了强大的自动化分析功能，大大简化了固件的安全审计工作。
​     他基于Ghidra逆向工程框架，通过定制的Ghidra脚本，如ref2sink_cmdi和ref2sink_bof，自动追踪可能的风险路径。这些脚本能够挖掘命令注入和缓冲区溢出类漏洞的源码路径。此外，ref2share和share2sink脚本组合使用，可以探测到共享输入数据导致的问题。工具还集成了污点分析，增强了对潜在风险的识别能力。


satc工作流程图如下：
![](vx_images/369841413594773.png) 


通过跟踪前端和后端之间用户输入的数据流，以精确检测安全漏洞。处理用户输入的后端函数通常与相应的前端文件共享一个关键字：在前端，用户输入被标记为关键字并编码在数据包中；在后端，使用相同或相似的关键字从数据包中提取用户输入。因此，可以使用共享关键字来标识前端和后端之间的连接，并在后端找到用户输入的入口。


# SaTC实例测试
原文链接：[github](https://github.com/NSSL-SJTU/SaTC/blob/py2_env/README_CN.md)

## 安装

拉取镜像前，需要配置docker源
```
sudo mkdir -p /etc/docker
sudo vim /etc//docker/daemon.json
#这是daemon.json添加的内容
{
    "registry-mirrors": [    	"https://dockerpull.com",
        "https://docker.anyhub.us.kg",
        "https://dockerhub.jobcher.com",
        "https://dockerhub.icu",
        "https://docker.awsl9527.cn"
    ]
}
#重启docker服务
sudo systemctl daemon-reload && sudo systemctl restart docker
```

拉取镜像
```
# 拉取docker镜像
docker pull smile0304/satc
# 进入docker环境
docker run -it smile0304/satc:V1.0
# 安装pip requirement
pip install -r requirement.txt

```

运行
```
docker images
docker run -it smile0304/satc
```


将要分析的文件系统拷贝到docker中
```
docker cp ./squashfs-root/ 1a26501ac6fe:/home/satc/SaTC/tendaac15
```


使用方法：
```
usage: satc.py [-h] -d /root/path/_ac18.extracted -o /root/output
               [--ghidra_script {ref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all}]
               [--save_ghidra_project] --taint_check
               [-b /var/ac18/bin/httpd | -l 3]

SATC tool

optional arguments:
  -h, --help            查看帮助
  -d /root/path/_ac18.extracted, --directory /root/path/_ac18.extracted
                        指定从固件中提取出的文件系统
  -o /root/output, --output /root/output
                        指定结果输出位置
  --ghidra_script {ref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all}
                        (可选) 指定要使用的 Ghidra 脚本。 如果使用`all`命令，`ref2sink_cmdi`、`ref2sink_bof`和`ref2share`三个脚本将同时运行
  --ref2share_result /root/path/ref2share_result  (可选) 运行`share2sink` Ghidra脚本时，需要使用该参数指定`ref2share`脚本的输出结果
  --save_ghidra_project (可选) 是否保存程序运行时产生的ghidra工程路径
  --taint_check         (可选) 指定是否启用污点分析
  -b /var/ac18/bin/httpd, --bin /var/ac18/bin/httpd
                        (可选) 用于指定需要分析的程序，如果不指定，SaTC将使用内置算法确认需要分析的程序
  -l 3, --len 3         (可选) 根据分析结果分析可能为边界的前N个程序，默认为3
```

Ghidra Script info
```
ref2sink_cmdi : 该脚本从给定的字符串的引用中找到命令注入类型sink函数的路径。
ref2sink_bof : 改脚本从给定的字符串的引用中找到缓冲区溢出类型sink函数的路径。
ref2share: 此脚本用来查找输入等字符串中被写入共享函数等参数，例如:nvram_set, setenv等函数。需要与share2sink来配合使用
share2sink: 此脚本与ref2share功能类似。需要与ref2share来配合使用；使用此脚本的输入为ref2share脚本的输出

```




# ac15实际测试
测试httpd中是否存在命令注入漏洞
```
python satc.py -d /home/satc/SaTC/tendaac15/squashfs-root/ -o /home/satc/SaTC/res_ac15 --ghidra_script=ref2sink_cmdi -b httpd --taint_check
```

![](vx_images/112206572116524.png)
程序会自动开始跑，这一过程需要很久很久。


最终污点分析结果存储在了result-httpd-ref2sink_cmdi-6MIi.txt中

从结果中看到，httpd的0xa68f8位置疑似存在命令执行，并且该位置的命令执行在sink函数路径文件中也有体现污点传播过程。

```
ghidra_extract_result/httpd/httpd_ref2sink_cmdi.result:[Param "deviceName"(0x000f2208), Referenced at formsetUsbUnload : 0x000a68c4] >> 0x000a68f4 -> doSystemCmd
```

接下来就是手动确定的工作了。
查找前端对应点：由于在污点传播过程中deviceName是前后端的 shared key-Value
在文件结构web目录中查找deviceName即可找到对应的前端页面然后进行手工验证
```
$ grep -ir "devicename"|awk -F ":" '{print($1)}'|grep -E 'html|js'|sort|uniq
......
status_usb.html
status_usb.js
```

最后这里的漏洞编号是cve-2020-10987，之前做个这个漏洞复现，就不再做一遍了（https://github.com/theRaz0r/Iot-vulnerability/blob/main/Tenda/AC15_command_injection/AC15_command_injection.md）



